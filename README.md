### Data-Structures-Algorithms-Goodrich
Exercises For the Data Structures and Algorithms in Python by Goodrich, Tamassia

+ All the solutions are presented in jupyter notebooks (.py extensions are also added)
+ All algorithms, that are covered in Goodrich book are implemented in this Git repo.
+ You can download the book [here](https://github.com/absognety/Technology-Books/blob/master/Reference%20Books/Python/Data%20Structures%20and%20Algorithms%20in%20Python%20%5BGoodrich%2C%20Tamassia%20%26%20Goldwasser%202013-03-18%5D.pdf)

#### Contents


+ Chapter - 1: Python Primer<br/>
  - Python Overview<br/>
       1. The Python Interpreter<br/>
       2. Preview of a Python Program<br/>
  - Objects in Python<br/>
       1. Identifiers, Objects and the Assignment Statement<br/>
       2. Creating and using objects<br/>
       3. Python's Built-in classes<br/>
  - Expressions, Operators and Precedence<br/>
       1. Compound Expressions and Operator precedence<br/>
  - Control Flow<br/>
       1. Conditionals<br/>
       2. Loops<br/>
  - Functions<br/>
       1. Information passing<br/>
       2. Python's Built-in Functions<br/>
  - Simple Input and Output<br/>
       1. Console Input and Output<br/>
       2. Files<br/>
  - Exception Handling<br/>
       1. Raising an Exception<br/>
       2. Catching an Exeption<br/>
  - Iterators and Generators<br/>
  - Additional Python Conveniences<br/>
       1. Conditional Expressions<br/>
       2. Comprehension Syntax<br/>
       3. Packing and Unpacking of Sequences<br/>
  - Scopes and Namespaces<br/>
  - Modules and Import Statement<br/>
       1. Existing Modules<br/>
  - Exercises<br/>
   
  
+ Chapter - 2: Object-Oriented Programming<br/>
  - Goals, Principles and Patterns<br/>
       1. Object-Oriented Design Goals<br/>
       2. Object-Oriented Design Principles<br/>
       3. Design Patterns<br/>
  - Software Development<br/>
       1. Design<br/>
       2. Pseudo-Code<br/>
       3. Coding Style and Documentation<br/>
       4. Testing and Debugging<br/>
  - Class Definitions<br/>
       1. Example: Credit Class<br/>
       2. Operator Overloading and Python's Special Methods<br/>
       3. Example: Multidimensional Vector Class<br/>
       4. Iterators<br/>
       5. Example: Range Class<br/>
  - Inheritance   
       1. Extending the Credit Card Class  
       2. Hierarchy of Numeric Progression  
       3. Abstract Base Classes  
  - Namespaces and Object-Orientation  
       1. Instance and Class Namespaces  
       2. Name Resolution and Dynamic Dispatch  
  - Shallow and Deep Copying  
  - Exercises     
 
 
+ Chapter - 3: Algorithm Analysis  
  - Experimental Studies  
       1. Moving Beyond Experimental Analysis  
  - The Seven Functions Used in This Book  
       1. Comparing Growth Rates  
  - Asymptotic Analysis  
       1. The "Big-Oh" Notation  
       2. Comparative Analysis  
       3. Examples of Algorithm Analysis  
  - Simple Justification Techniques  
       4. By Example  
       5. The "Contra" Attack  
       6. Induction and Loop Invariants  
  - Exercises  
   
   
+ Chapter - 4: Recursion  
  - Illustrative Functions  
       1. The Factorial Function  
       2. Drawing an English Ruler  
       3. Binary Search  
       4. File Systems  
  - Analyzing Recursive Algorithms  
  - Recursion Run Amok  
       1. Maximum Recursive Depth in Python  
  - Further Examples of Recursion  
       1. Linear Recursion  
       2. Binary Recursion  
       3. Multiple Recursion  
  - Designing Recursive Algorithms  
  - Eliminating Tail Recursion  
  - Exercises  
   
   
+ Chapter - 5: Array Based Sequences  
  - Python's Sequence Types  
  - Low-Level Arrays  
       1. Referential Arrays  
       2. Compact Arrays in Python  
  - Dynamic Arrays and Amortization  
       1. Implementing a Dynamic Array  
       2. Amortized Analysis of Dynamic Arrays  
       3. Python's List Class  
  - Efficiency Of Python's Sequence Types  
       1. Python’s List and Tuple Classes  
       2. Python’s String Class  
  - Using Array-Based Sequences  
       1. Storing High Scores for a Game  
       2. Sorting a Sequence  
       3. Simple Cryptography  
  - Multidimensional Data Sets  
  - Exercises  
  
  
+ Chapter - 6: Stacks Queues and Deques  
  - Stacks  
       1. The Stack Abstract Data Type  
       2. Simple Array-Based Stack Implementation  
       3. Reversing Data Using a Stack  
       4. Matching Parenthesis and HTML Tags  
  - Queues  
       1. The Queue Abstract Data Type  
       2. Array-Based Queue Implementation  
  - Double-Ended Queues  
       1. The Deque Abstract Data Type  
       2. Implementing a Deque with a Circular Array  
       3. Deques in the Python CollectionsModule  
  - Exercises  
  
  
+ Chapter - 7: Linked Lists  
  - Singly Linked Lists  
       1. Implementing a Stack with a Singly Linked List  
       2. Implementing a Queue with a Singly Linked List  
  - Circularly Linked Lists  
       1. Round-Robin Schedulers  
       2. Implementing a Queue with a Circularly Linked List  
  - Doubly Linked Lists  
       1. Basic Implementation of a Doubly Linked List  
       2. Implementing a Deque with a Doubly Linked List  
  - The Positional List ADT  
       1. The Positional List Abstract Data Type  
       2. Doubly Linked List Implementation  
  - Sorting a Positional List  
  - Case Study: Maintaining Access Frequencies  
       1. Using a Sorted List  
       2. Using a List with theMove-to-Front Heuristic  
  - Link-Based vs. Array-Based Sequences  
  - Exercises  
    
  
+ Chapter - 8: Trees  
  - General Trees  
       1. Tree Definitions and Properties  
       2. The Tree Abstract Data Type  
       3. Computing Depth and Height  
  - Binary Trees  
       1. The Binary Tree Abstract Data Type  
       2. Properties of Binary Trees  
  - Implementing Trees  
       1. Linked Structure for Binary Trees  
       2. Array-Based Representation of a Binary Tree  
       3. Linked Structure for General Trees  
  - Tree Traversal Algorithms  
       1. Preorder and Postorder Traversals of General Trees  
       2. Breadth-First Tree Traversal  
       3. Inorder Traversal of a Binary Tree  
       4. Implementing Tree Traversals in Python  
       5. Applications of Tree Traversals  
       6. Euler Tours and the Template Method Pattern  
  - Case Study: An Expression Tree  
  - Exercises  
      
      
+ Chapter - 9: Priority Queues  
  - The Priority Queue Abstract Data Type  
       1. Priorities  
       2. The Priority Queue ADT  
  - Implementing a Priority Queue  
       1. The Composition Design Pattern  
       2. Implementation with an Unsorted List  
       3. Implementation with a Sorted List  
  - Heaps  
       1. The Heap Data Structure  
       2. Implementing a Priority Queue with a Heap  
       3. Array-Based Representation of a Complete Binary Tree  
       4. Python Heap Implementation  
       5. Analysis of a Heap-Based Priority Queue  
       6. Bottom-Up Heap Construction  
       7. Python’s heapq Module  
  - Sorting with a Priority Queue  
       1. Selection-Sort and Insertion-Sort  
       2. Heap-Sort  
  - Adaptable Priority Queues  
       1. Locators  
       2. Implementing an Adaptable Priority Queue  
  - Exercises  
      
      
+ Chapter - 10: Maps, Hash Tables and Skip Lists  
  - Maps and Dictionaries  
       1. The Map ADT  
       2. Application: CountingWord Frequencies  
       3. Python’s MutableMapping Abstract Base Class  
       4. Our MapBase Class  
       5. Simple UnsortedMap Implementation  
  - Hash Tables  
       1. Hash Functions  
       2. Collision-Handling Schemes  
       3. Load Factors, Rehashing, and Efficiency  
       4. Python Hash Table Implementation  
  - Sorted Maps  
       1. Sorted Search Tables  
       2. Two Applications of SortedMaps  
  - Skip Lists  
       1. Search and Update Operations in a Skip List  
       2. Probabilistic Analysis of Skip Lists  
  - Sets, Multisets, and Multimaps  
       1. The Set ADT  
       2. Python’s MutableSet Abstract Base Class  
       3. Implementing Sets,Multisets, andMultimaps  
  - Exercises  
   
   
+ Chapter - 11: Search Trees  
  - Binary Search Trees  
       1. Navigating a Binary Search Tree  
       2. Searches  
       3. Insertions and Deletions  
       4. Python Implementation  
       5. Performance of a Binary Search Tree  
  - Balanced Search Trees  
       1. Python Framework for Balancing Search Trees  
  - AVL Trees  
       1. Update Operations  
       2. Python Implementation  
  - Splay Trees  
       1. Splaying  
       2. When to Splay  
       3. Python Implementation  
       4. Amortized Analysis of Splaying  
  - (2,4) Trees  
       1. Multiway Search Trees  
       2. (2,4)-Tree Operations  
  - Red-Black Trees  
       1. Red-Black Tree Operations  
       2. Python Implementation  
  - Exercises  
   
   
+ Chapter - 12: Sorting and Selection  
  - Why Study Sorting Algorithms?  
       1. Merge-Sort  
       2. Divide-and-Conquer  
       3. Array-Based Implementation ofMerge-Sort  
       4. The Running Time of Merge-Sort  
       5. Merge-Sort and Recurrence Equations  
       6. Alternative Implementations ofMerge-Sort  
  - Quick-Sort  
       1. Randomized Quick-Sort  
       2. Additional Optimizations for Quick-Sort  
  - Studying Sorting through an Algorithmic Lens  
       1. Lower Bound for Sorting  
       2. Linear-Time Sorting: Bucket-Sort and Radix-Sort  
  - Comparing Sorting Algorithms  
  - Python’s Built-In Sorting Functions  
       1. Sorting According to a Key Function  
  - Selection  
       1. Prune-and-Search  
       2. Randomized Quick-Select  
       3. Analyzing Randomized Quick-Select  
  - Exercises  
   
   
+ Chapter - 13: Text Processing  
  - Abundance of Digitized Text  
       1. Notations for Strings and the Python str Class  
  - Pattern-Matching Algorithms  
       1. Brute Force  
       2. The Boyer-Moore Algorithm  
       3. The Knuth-Morris-Pratt Algorithm  
  - Dynamic Programming  
       1. Matrix Chain-Product  
       2. DNA and Text Sequence Alignment  
  - Text Compression and the Greedy Method  
       1. The Huffman Coding Algorithm  
       2. The GreedyMethod  
  - Tries  
       1. Standard Tries  
       2. Compressed Tries  
       3. Suffix Tries  
       4. Search Engine Indexing  
  - Exercises  
   
   
+ Chapter - 14: Graph Algorithms  
  - Graphs  
       1. The Graph ADT  
  - Data Structures for Graphs  
       1. Edge List Structure  
       2. Adjacency List Structure  
       3. Adjacency Map Structure  
       4. AdjacencyMatrix Structure  
       5. Python Implementation  
  - Graph Traversals  
       1. Depth-First Search  
       2. DFS Implementation and Extensions  
       3. Breadth-First Search  
  - Transitive Closure  
  - Directed Acyclic Graphs  
       1. Topological Ordering  
  - Shortest Paths  
       1. Weighted Graphs  
       2. Dijkstra’s Algorithm  
  - Minimum Spanning Trees  
       1. Prim-Jarn´ık Algorithm  
       2. Kruskal’s Algorithm  
       3. Disjoint Partitions and Union-Find Structures  
  - Exercises  
   
   
+ Chapter - 15: Memory Management and B-Trees  
  - Memory Management  
       1. Memory Allocation  
       2. Garbage Collection  
       3. Additional Memory Used by the Python Interpreter  
  - Memory Hierarchies and Caching  
       1. Memory Systems  
       2. Caching Strategies  
  - External Searching and B-Trees  
       1. (a,b) Trees  
       2. B-Trees  
  - External-Memory Sorting  
       1. MultiwayMerging  
  - Exercises  
